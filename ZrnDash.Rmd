---
title: "ZrnDash"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    social: menu
    vertical_layout: scroll
---

```{r setup, include=FALSE}
# RMarkdown zircon geochronology dashboard template updated 2018.08.22 CH.

# install missing packages, load packages
  # knitr for assembling RMarkdown documents
  if(!require(knitr)){install.packages("knitr")}  # install
  library(knitr)  # load
  # ggplot for making graphs
  if(!require(ggplot2)){install.packages("ggplot2", dependencies = TRUE)}
  library(ggplot2)  # load
  # plyr for combining data frames, displaying dashboard
  if(!require(plyr)){install.packages("plyr")}  # install
  library(plyr)  # load
  # dplyr for making plotly work
  if(!require(dplyr)){install.packages("dplyr", dependencies = TRUE)} 
  library(dplyr)  # load
  # plotly for making interactive graphs
  if(!require(plotly)){install.packages("plotly", dependencies = TRUE)} 
  library(plotly)  # load
  # flexdashboard for making dashboards
  if(!require(flexdashboard)){install.packages("flexdashboard")}  # install
  library(flexdashboard)  # load
  # RColorBrewer package for color palette
  if(!require(RColorBrewer)){install.packages("RColorBrewer")}  # install
  library(RColorBrewer)  # load
  # reshape2 for melting data frames
  if(!require(reshape2)){install.packages("reshape2")}  # install
  library(reshape2)  # load
  # leaflet extracts color codes from a palette given a value (for REE plots)
  if(!require(leaflet)){install.packages("leaflet")}  # install
  library(leaflet)  # load
  # ggfortify for plotting output of MDS
  if(!require(ggfortify)){install.packages("ggfortify")}  # install
  library(ggfortify)  # load
  # BBmisc for normalizing data frame function
  if(!require(BBmisc)){install.packages("BBmisc")}  # install
  library(BBmisc)  # load
  # The pcaMethods package allows you to do PCA on datasets with missing (NA) or
  # outlier data. 
  # https://bioconductor.org/packages/release/bioc/html/pcaMethods.html
  if(!require(pcaMethods)){source("https://bioconductor.org/biocLite.R")
  biocLite("pcaMethods")}  # install
  library(pcaMethods)  # load


# clear all from workspace/environment
  rm(list=ls())

# Set universal settings. 
  # For all code chunks, omit code in knited document and hide messages and 
  # warnings.
  knitr::opts_chunk$set(echo=FALSE, message=FALSE, warning=FALSE) 

  # Set working directory.
  knitr::opts_knit$set(root.dir = 
  "/Users/claireharrigan/Dropbox/IGL + Research/R/graphit/")
```

```{r import, include=FALSE}
# functions required:
  source("ImportZirconFDT.R") # for importing and cleaning up files
  source("SplitAnalysis.R") # for cleaning up LA-ICPMS analysis strings 
  
# Import zircon LA-ICPMS data.
  # First, save your final data table as a .csv file with the values as numbers
  # with many decimal places.
  # Type file.choose() in the console, then hit enter to select the file. Copy
  # and paste the resulting filepath into the function below.
  ImportedDF <- ImportZirconFDT("/Users/claireharrigan/Dropbox/IGL + Research/Sierra Nevada/Results/17RF11 (Kmr)/17RF11-1 zrn_FDT.csv")
  # Save a data frame of LA-ICPMS samples only (no standards).
  DF <- ImportedDF[[1]]
  # Apply the SplitAnalysis function to the analysis column and save the results
  # as a temporary dataframe.
  tempDF <- SplitAnalysis(column.name = DF$analysis) 
  # Save sample name from temporary dataframe into the main dataframe.
  DF$sample <- tempDF$samp.name
  # Save mount size from temporary dataframe into the main dataframe.
  DF$size <- tempDF$size 
  # Save spot number from temporary datafrae into the main dataframe.
  DF$spot <- tempDF$spot 
  # OPTIONALL Remove spots that are not zircon (uncomment next line and edit).
  #DF <- subset(DF, spot != 135)
  rm(tempDF)  # remove temporary data frame from environment

# OPTIONAL: Import a second zircon LA-ICPMS final data table 
# Uncomment this section and edit filepath of the next line to import a second
# final data table.
  # ImportedDF2 <- Import("/Users/claireharrigan/Dropbox/IGL + Research/WISZ/Results/14WZ3-2 LGCC Gpg/zircon/Geochemistry/zircon_14WZ3-2_LA-ICPMS FDT.csv")
  # # Save a data frame of LA-ICPMS samples only (no standards).
  # DF2 <- ImportedDF2[[1]]
  # # Apply the SplitAnalysis function to the analysis column and save the results
  # # as a temporary dataframe.
  # tempDF2 <- SplitAnalysis(column.name = DF2$analysis) 
  # # Save sample name from temporary dataframe into the main dataframe.
  # DF2$sample <- tempDF2$samp.name
  # # Save mount size from temporary dataframe into the main dataframe.
  # DF2$size <- tempDF2$size 
  # # Save spot number from temporary datafrae into the main dataframe.
  # DF2$spot <- tempDF2$spot 
  # # Remove spots that are not zircon (optional--uncomment next line and edit).
  # #DF2 <- subset(DF2, spot != 135)
  # rm(tempDF2)  # remove temporary data frame from environment

# OPTIONAL: Bind all imported data frames together and remove extra data frames.
# Uncomment the following section if importing multiple final data tables.
  # DF <- rbind.fill(DF, DF2)  # Combine using rbind.fill function from plyr.
  # rm(DF2)  # Remove individual sample data frames.
```

```{r set_values, include=FALSE}
# Set values for Ti-in-zircon thermometer.
  aTiO2 = 0.7     # set activity of TiO2
  aSiO2 = 1       # set activity of SiO2

# Set text to describe samples.
sample.notes = "This is the template for creating a zircon geochemistry dashboard with LA-ICPMS data."
```

```{r calculate, include=FALSE}
# functions required for calculations and plotting:
  source("ChondriteNormalization.R")  # for normalizing REE values
  source("CalculateRatios.R")  # for calculating trace element ratios
  source("PlotlyBivariateZrn.R")  # for making interactive bivariate plots
  source("PlotlySummedPDFZrn.R")  # for making interactive summed PDF
  source("PlotlyREE.R")  # for making interactive REE plots

# Create new columns based on sample, size, and spot information.
  # Create "size spot" column for unique naming for PCA and MDS (ex. "M 132").
  DF$size.spot <- paste(DF$size, " ", DF$spot, sep="") # create 
  # Create "sample size spot" column for unique naming for PCA and MDS.
  DF$sample.size.spot <- paste(DF$sample, " ", DF$size, " ", DF$spot, sep="")

# Create chondrite normalized REE values for plotting REE patterns.
  DF <- ChondriteNormalization(DF)

# Calculate temperature in Â°C using Ferry and Watson (2007) Ti-in-zircon 
# thermometer and save as a column in data frame.
  DF$temperature <- (-4800 / (log10(DF$Ti) - 5.711 + log10(aSiO2) - 
                     log10(aTiO2))) - 273.15

# Sort the data frame by decreasing temperature.
  DF <- DF[order(DF$temperature, decreasing = TRUE), ] 

# Calculate trace element and REE ratios. Round temperature.
  DF <- CalculateRatios(DF)
  
# Make a new column in the data frame of your preferred age and error.
  DF$Age <- DF$Age_CalibError_206Pb238U
  DF$Age2sig <- DF$Age_CalibError_206Pb238U_2sig
  # Round these columns (save as new column) to one decimal place (useful for
  # labeling).
  DF$Age_round <- round(DF$Age, digits = 1)
  DF$Age2sig_round <- round(DF$Age2sig, digits = 1)
```

Bivariate plots
================================================================================
`r sample.notes`

Row
--------------------------------------------------------------------------------

### Probability Density Function (PDF) of LA-ICPMS Age
```{r page1_1}
PlotlySummedPDFZrn(DF)
```

### Age vs. Total REE
```{r page1_2}
PlotlyBivariateZrn(dataframe = DF,  
                   x.value   = Age, 
                   x.name    = "Age (Ma)", 
                   y.value   = sumREE, 
                   y.name    = "Total REE (ppm)")
```

Row
--------------------------------------------------------------------------------

### Eu anomaly vs. Total REE
```{r page1_3}
PlotlyBivariateZrn(dataframe = DF,  
                   x.value   = EuEustar, 
                   x.name    = "Eu/Eu*", 
                   y.value   = sumREE, 
                   y.name    = "Total REE (ppm)")
```

### Dy anomaly vs. Total REE
```{r page1_4}
PlotlyBivariateZrn(dataframe = DF,  
                   x.value   = DyDystar, 
                   x.name    = "Dy/Dy*", 
                   y.value   = sumREE, 
                   y.name    = "Total REE (ppm)")
```

Row
--------------------------------------------------------------------------------

### U vs. Total REE
```{r page1_5}
PlotlyBivariateZrn(dataframe = DF,  
                   x.value   = U, 
                   x.name    = "U (ppm)", 
                   y.value   = sumREE, 
                   y.name    = "Total REE (ppm)")
```

### Th/U vs. Total REE
```{r page1_6}
PlotlyBivariateZrn(dataframe = DF,  
                   x.value   = ThU, 
                   x.name    = "Th/U", 
                   y.value   = sumREE, 
                   y.name    = "Total REE (ppm)")
```

Row
--------------------------------------------------------------------------------

### Lu/Hf vs. Total REE
```{r page1_7}
PlotlyBivariateZrn(dataframe = DF,  
                   x.value   = LuHf, 
                   x.name    = "Lu/Hf", 
                   y.value   = sumREE, 
                   y.name    = "Total REE (ppm)")
```

### Zr/Hf vs. Total REE
```{r page1_8}
PlotlyBivariateZrn(dataframe = DF,  
                   x.value   = ZrHf, 
                   x.name    = "Zr/Hf", 
                   y.value   = sumREE, 
                   y.name    = "Total REE (ppm)")
```

Row
--------------------------------------------------------------------------------

### Nb/Th vs. Total REE
```{r page1_9}
PlotlyBivariateZrn(dataframe = DF,  
                   x.value   = NbTh, 
                   x.name    = "Nb/Th", 
                   y.value   = sumREE, 
                   y.name    = "Total REE (ppm)")
```

### Nb/Ta vs. Total REE
```{r page1_10}
PlotlyBivariateZrn(dataframe = DF,  
                   x.value   = NbTa, 
                   x.name    = "Nb/Ta", 
                   y.value   = sumREE, 
                   y.name    = "Total REE (ppm)")
```


REE plots
================================================================================
`r sample.notes`  
REE plots are colored by the same temperature scale used for the bivariate plots.

Row
--------------------------------------------------------------------------------
```{r REE_setup, include = FALSE}
# Resort the data frame by increasing temperature.
  DF.REE <- DF[order(DF$temperature, decreasing = FALSE), ] 
```

### REE plot 1
```{r page2_1}
PlotlyREE(dataframe    = DF.REE,
          start.sample = DF.REE[[(dim(DF.REE)[1] / 4 * 3 + 1), 
                                 "sample.size.spot"]],
          end.sample   = DF.REE[[(dim(DF.REE)[1]), "sample.size.spot"]])
```

### REE plot 2
```{r page2_2}
PlotlyREE(dataframe    = DF.REE,
          start.sample = DF.REE[[(dim(DF.REE)[1] / 4 * 2 + 1), 
                                 "sample.size.spot"]],
          end.sample   = DF.REE[[(dim(DF.REE)[1] / 4 * 3), "sample.size.spot"]])
```

Row
--------------------------------------------------------------------------------

### REE plot 3
```{r page2_3}
PlotlyREE(dataframe    = DF.REE,
          start.sample = DF.REE[[(dim(DF.REE)[1] / 4 + 1), "sample.size.spot"]],
          end.sample   = DF.REE[[(dim(DF.REE)[1] / 4 * 2), "sample.size.spot"]])
```

### REE plot 4
```{r page2_4}
PlotlyREE(dataframe    = DF.REE,
          start.sample = DF.REE[[1, "sample.size.spot"]],
          end.sample   = DF.REE[[(dim(DF.REE)[1] / 4), "sample.size.spot"]])
```


Principal component analysis
================================================================================
`r sample.notes`  
This section is in progress.
Need to include notes about parameters used for PCA (scaling, centering, etc.).

Row
-------------------------------------------------------------------------------
### PCA scree plot
```{r PCA_1, echo=FALSE, message=FALSE, warning=FALSE}
# Set up for PCA 
  # Make data frame of variables to be included in MDS/PCA and for labeling.
  DF.PCA <- subset(DF, select = c(sample, sample.size.spot,
                                  Age_round, Age2sig_round, 
                                  Pbstar, Ti, Y, Zr, Nb, Lu, Hf, Ta, 
                                  Th, U, 
                                  La_CN, Ce_CN, Pr_CN, Nd_CN, Pm_CN, 
                                  Sm_CN, Eu_CN, Gd_CN, Tb_CN, Dy_CN, 
                                  Ho_CN, Er_CN, Tm_CN, Yb_CN, Lu_CN, 
                                  temperature_r, sumREE, 
                                  LaNd, GdLu, GdYb, ZrHf, LuHf, HfY, 
                                  YHo, ThU, ThY, NbTa, NbU, NbTh, 
                                  DyYb,
                                  CeCestar, EuEustar, DyDystar)) 

  # Make age and error character strings so they do not get normalized with the 
  # rest of the numeric data in the data frame.
  DF.PCA[["sample"]] <- as.character(DF.PCA[["sample"]])
  DF.PCA[["sample.size.spot"]] <- as.character(DF.PCA[["sample.size.spot"]])
  DF.PCA[["Age_round"]] <- as.character(DF.PCA[["Age_round"]])
  DF.PCA[["Age2sig_round"]] <- as.character(DF.PCA[["Age2sig_round"]])

  # Do principal component analysis.
  # Center the matrix to make the SVD method like doing standard PCA via a
  # covariance matrix. Use pareto scaling. Pull out ten principal components.
  pc.results <- pca(DF.PCA, scale = "pareto", center = TRUE, nPcs = 10)
  # pc.test.1 <- pca(DF.PCA, scale = "uv", center = TRUE, nPcs = 10)
  
  # Store the results of the principal component analysis in a data frame for 
  # plotting.
  # Save the variance percent in the data frame.
  PCA.results <- as.data.frame(pc.results@R2)
  # Save the cummulative percent in the data frame.
  PCA.results$cummulative.percent <- pc.results@R2cum
  # Make a column of axis labels.
  PCA.results$axis.labels <- c("PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", 
                             "PC8", "PC9", "PC10")
  # Make the axis label column into factors so it does not plot alphabetically.
  PCA.results$axis.labels <- factor(PCA.results$axis.labels, levels = c("PC1", 
                             "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", 
                             "PC9", "PC10"))
  # Name the data frame rows using the axis labels column.
  rownames(PCA.results) <- PCA.results$axis.labels
  # Rename the columns.
  colnames(PCA.results) <- c("VariancePercent", "CummulativePercent",
                             "PrincipalComponent")
  # Create a column of rounded variance percent for hovertext.
  PCA.results$VariancePercent_round <- round(PCA.results$VariancePercent * 100, 
                                             digits = 1)
  # Create a column of rounded cummulative percent for hovertext.
  PCA.results$CummulativePercent_round <- round(PCA.results$CummulativePercent 
                                                * 100, digits = 1)
  
# Make a scree plot.
  plot_ly(data = PCA.results, 
          x = ~PrincipalComponent, 
          y = ~VariancePercent,
          name = "Variance percent",
          type = "bar",
          marker = list(color = "gray"),
          hoverinfo = 'text',
          text = ~paste(PrincipalComponent,
                        "<br>Variance percent: ",
                        VariancePercent_round, "%",
                        "<br>Cummulative percent: ",
                        CummulativePercent_round, "%", 
                        sep = '')) %>%
    add_trace(data = PCA.results, 
              x = ~PrincipalComponent, 
              y = ~VariancePercent, 
              type = "scatter", 
              mode = "lines+markers", 
              line = list(color = "black"), 
              marker = list(color = "black")) %>%
    add_trace(data = PCA.results, 
              x = ~PrincipalComponent, 
              y = ~CummulativePercent, 
              name = "Cummulative percent",
              type = "scatter", 
              mode = "lines+markers", 
              line = list(color = "red"), 
              marker = list(color = "red")) %>%
    layout(xaxis = list(title = "Principal component"), 
           yaxis = list(title = "Percentage of explained variance"))
  
  # need to change so y axis says 80% instead of 0.8  



# 
# data(iris)
# ##  Usually some kind of scaling is appropriate
# pcIr <- pca(iris, method="svd", nPcs=2)
# pcIr <- pca(iris, method="nipals", nPcs=3, cv="q2")
# ## Get a short summary on the calculated model
# summary(pcIr)
# plot(pcIr)
# ## Scores and loadings plot
# slplot(pcIr, sl=as.character(iris[,5]))
# data(sample.ExpressionSet)
# pc <- pca(sample.ExpressionSet)
# df <- merge(scores(pc), pData(sample.ExpressionSet), by=0)
# library(ggplot2)
# ggplot(df, aes(PC1, PC2, shape=sex, color=type)) +
#   geom_point() +
#   xlab(paste("PC1", pc@R2[1] * 100, "% of variance")) +
#   ylab(paste("PC2", pc@R2[2] * 100, "% of variance"))


```




```{r MDS, echo=FALSE, message=FALSE, warning=FALSE}
# # Set up for MDS and PCA 
#   # Make data frame of variables to be included in MDS/PCA and for labeling.
#   DF.PCA <- subset(DF, select = c(sample, sample.size.spot,
#                                   Age_round, Age2sig_round, 
#                                   Pbstar, Ti, Y, Zr, Nb, Lu, Hf, Ta, 
#                                   Th, U, 
#                                   La_CN, Ce_CN, Pr_CN, Nd_CN, Pm_CN, 
#                                   Sm_CN, Eu_CN, Gd_CN, Tb_CN, Dy_CN, 
#                                   Ho_CN, Er_CN, Tm_CN, Yb_CN, Lu_CN, 
#                                   temperature_r, sumREE, 
#                                   LaNd, GdLu, GdYb, ZrHf, LuHf, HfY, 
#                                   YHo, ThU, ThY, NbTa, NbU, NbTh, 
#                                   DyYb,
#                                   CeCestar, EuEustar, DyDystar)) 
# 
#   # Make age and error character strings so they do not get normalized with the 
#   # rest of the numeric data in the data frame.
#   DF.PCA[["sample"]] <- as.character(DF.PCA[["sample"]])
#   DF.PCA[["sample.size.spot"]] <- as.character(DF.PCA[["sample.size.spot"]])
#   DF.PCA[["Age_round"]] <- as.character(DF.PCA[["Age_round"]])
#   DF.PCA[["Age2sig_round"]] <- as.character(DF.PCA[["Age2sig_round"]]) 
#   
#   # Normalize numerical values (max = 1, min = 0 for each column).
#   DF.PCA <- normalize(DF.PCA, method = "range", range = c(0,1)) 
#   
#   # Rename rows by sample, size, and spot for labeling later.
#   row.names(DF.PCA) <- t(DF.PCA$sample.size.spot) 
#   
# # Uncomment the following lines to make MDS plots.  
#   # # Transpose data frame so geochemical variables are rows.
#   # DF.MDA <- t(DF.PCA) 
#   # 
#   # # Label rows with names that can be used later for labeling.
#   # row.names(DF.MDA) <- c("Sample", "Sample Size Spot",
#   #                        "Age", "Age Error (2 sigma)",
#   #                        "Pb*", "Ti", "Y", "Zr", "Nb", "Lu", "Hf", "Ta", 
#   #                        "Th", "U", 
#   #                        "La (CN)", "Ce (CN)", "Pr (CN)", "Nd (CN)", "Pm (CN)", 
#   #                        "Sm (CN)", "Eu (CN)", "Gd (CN)", "Tb (CN)", "Dy (CN)", 
#   #                        "Ho (CN)", "Er (CN)", "Tm (CN)", "Yb (CN)", "Lu (CN)", 
#   #                        "Temperature (Â°C)", "Total REE",
#   #                        "La/Nd", "Gd/Lu", "Gd/Yb", "Zr/Hf", "Lu/Hf", "Hf/Y", 
#   #                        "Y/Ho", "Th/U", "Th/Y", "Nb/Ta", "Nb/U", "Nb/Th", 
#   #                        "Dy/Yb",
#   #                        "Ce/Ce*", "Eu/Eu*", "Dy/Dy*")
#   
# # # Make MDS plot.
# #   # Find the Euclidian distance between the rows.
# #   dist.MDS <- dist(DF.MDA[10:dim(DF.MDA), ])
# #   # Make plot.
# #   ggplotly(autoplot(cmdscale(dist.MDS, eig = TRUE), 
# #                     shape = FALSE, label = TRUE, label.size = 3))
# # 
# # # Make heatmap of Euclidian distance between the rows.  
# #   autoplot(dist.MDS) + scale_fill_gradient(low = "white", high = "steelblue4")
```


Row
--------------------------------------------------------------------------------
### PCA scree plot

```{r PCA1, echo=FALSE, message=FALSE, warning=FALSE}
# # Set up for PCA and PCA scree plot.
#   # Do a principal component analysis on the numerical (not identifying) columns 
#   # of the DF.PCA data frame.
#   PCA.results <- prcomp(DF.PCA[, 10:(dim(DF.PCA)[2])], scale = TRUE) 
#   
#   # Create a data frame to store more results from PCA, particularly the 
#   # eigenvalues and variance percents.
#   eig.val <- data.frame(sdev = PCA.results$sdev, 
#                         eigenvalue = PCA.results$sdev^2, 
#                         variance.percent = (PCA.results$sdev^2 / 
#                                               sum(PCA.results$sdev^2)) * 100, 
#                         cummulative.percent = cumsum(PCA.results$sdev^2) / 
#                                                 sum(PCA.results$sdev^2) * 100)
#   
#   # Initialize row name list.
#   eig.val.rownames <- 0
#   # Create a list of character strings that will be used for row names.
#   for (n in 10:(dim(DF.PCA)[2])) {
#     eig.val.rownames[n - 9] <- as.list(paste("PC ", n - 9, sep=""))} 
#   # Save list of dimensions as row names in eig.val data frame
#   rownames(eig.val) <- eig.val.rownames 
#   # Save a column for labeling.
#   eig.val$axlabs <- eig.val.rownames 
#   
#   # Round variance percent for hovertext.
#   eig.val$variance.percent_r <- round(eig.val$variance.percent, digits = 2) 
#   # Round cummulative percent for hovertext.
#   eig.val$cummulative.percent_r <- round(eig.val$cummulative.percent, 
#                                          digits = 2) 
# 
# # Make scree plot.
# plot.scree <- plot_ly(data = eig.val, x = ~axlabs, y = ~variance.percent, # make scree bar plot
#                       type = "bar", name = "variance percent", marker = list(color = "steelblue"),
#                       text = ~paste("Variance percent: ", variance.percent_r, "%<br>Cummulative percent: ", cummulative.percent_r, "%", sep = "")) %>%
#                add_trace(data = eig.val, x = ~axlabs, y = ~variance.percent, 
#                       type = "scatter", mode = 'lines+markers', line = list(color = "black"), marker = list(color = "black")) %>%
#                add_trace(data = eig.val, x = ~axlabs, y = ~cummulative.percent, name = "cummulative percent",
#                       type = "scatter", mode = 'lines+markers', line = list(color = "gray"), marker = list(color = "gray")) %>%
#                layout(xaxis = list(title = "Principal component"), yaxis = list(title = "Percentage of explained variance"))
# plot.scree 
```




Row
----------------------------------------------------------
### Principal component analysis (PCA) scree plot
```{r PCA1, echo=FALSE, message=FALSE, warning=FALSE}
# PCA.results <- prcomp(DF.PCA[,10:(dim(DF.PCA)[2])], scale = TRUE) # do principal component analysis on the numerical (not identifying) columns of the DF.PCA data frame
# eig.val <- data.frame(sdev = PCA.results$sdev, eigenvalue = PCA.results$sdev^2, variance.percent = (PCA.results$sdev^2/sum(PCA.results$sdev^2))*100, cummulative.percent = cumsum(PCA.results$sdev^2)/sum(PCA.results$sdev^2)*100) # create a data frame to store more results from PCA, particularly the eigenvalues and variance percents
# eig.val.rownames <- 0 # initialize row name list
# for (n in 10:(dim(DF.PCA)[2])) {eig.val.rownames[n-9] <- as.list(paste("PC ",n-9,sep=""))} # create a list of character strings that will be used for row names
# rownames(eig.val) <- eig.val.rownames # save list of dimensions as row names in eig.val data frame
# eig.val$axlabs <- eig.val.rownames # save a column for labeling
# eig.val$variance.percent_r <- round(eig.val$variance.percent, digits = 2) # round variance percent for hovertext
# eig.val$cummulative.percent_r <- round(eig.val$cummulative.percent, digits = 2) # round cummulative percent for hovertext
# 
# # make scree plot
# plot.scree <- plot_ly(data = eig.val, x = ~axlabs, y = ~variance.percent, # make scree bar plot
#                       type = "bar", name = "variance percent", marker = list(color = "steelblue"),
#                       text = ~paste("Variance percent: ", variance.percent_r, "%<br>Cummulative percent: ", cummulative.percent_r, "%", sep = "")) %>%
#                add_trace(data = eig.val, x = ~axlabs, y = ~variance.percent, 
#                       type = "scatter", mode = 'lines+markers', line = list(color = "black"), marker = list(color = "black")) %>%
#                add_trace(data = eig.val, x = ~axlabs, y = ~cummulative.percent, name = "cummulative percent",
#                       type = "scatter", mode = 'lines+markers', line = list(color = "gray"), marker = list(color = "gray")) %>%
#                layout(xaxis = list(title = "Principal component"), yaxis = list(title = "Percentage of explained variance"))
# plot.scree 
```

### Principal component analysis (PCA) plot by sample
```{r PCA2, echo=FALSE, message=FALSE, warning=FALSE}
# # set up for PCA (by sample)
# PCA.sample <- data.frame(PCA.results$x, temperature = DF$temperature_r) # create a data frame of PC by sample
# 
# # st up for PCA (by variable)
# PCA.results.variable <- prcomp(t(DF.PCA[,10:(dim(DF.PCA)[2])]), scale = TRUE) # do principal component analysis on the identifying (not numerical) columns of the DF.PCA data frame
# PCA.variable <- data.frame(variable.label = c("Pb*", "Ti", "Sr", "Y", "Zr", "Nb", "Lu", "Hf", "Ta", "Th", "U", "La (CN)", "Ce (CN)", "Pr (CN)", "Nd (CN)", "Pm (CN)", "Sm (CN)", "Eu (CN)", "Gd (CN)", "Tb (CN)", "Dy (CN)", "Ho (CN)", "Er (CN)", "Tm (CN)", "Yb (CN)", "Lu (CN)", "Zr-in-ttn T (Â°C)", "La/Nd", "Gd/Lu", "Gd/Yb", "Zr/Hf", "Lu/Hf", "Hf/Y", "Y/Ho", "Th/U", "Th/Y", "Nb/Ta", "Nb/U", "Nb/Th", "Sr/Y", "Ce/Ce*", "Eu/Eu*", "Total REE", "LREE concavity", "HREE concavity"), PCA.results.variable$x)
# #PCA.variable <- rbind(PCA.variable, origin = vector(mode = "integer", length = dim(PCA.variable)[2])) # add a row to the PCA.variable data frame for plotting at the origin
# 
# # make plot of PCA
# plot.PCA <- plot_ly(data = PCA.sample, x = ~PC1, y = ~PC2,
#                            type = "scatter", 
#                            color = PCA.sample$temperature, colors = rev(brewer.pal(n=9, name="Spectral")),
#                            text = ~paste(rownames(PCA.sample), "<br>Temperature: ", temperature, "Â°C", sep =""))
# plot.PCA
```

### 3D principal component analysis (PCA) plot by sample
```{r PCA3d, echo=FALSE, message=FALSE, warning=FALSE}
# plot.PCA.3D <- plot_ly(data = PCA.sample, x = ~PC1, y = ~PC2, z = ~PC3, 
#                            type = "scatter3d",
#                            color = PCA.sample$temperature, colors = rev(brewer.pal(n=9, name="Spectral")),
#                            text = ~paste(rownames(PCA.sample), "<br>Temperature: ", temperature, "Â°C", sep =""))
# plot.PCA.3D
```


### Principal component analysis (PCA) plot by variable
```{r PCA2, echo=FALSE, message=FALSE, warning=FALSE}
# plot.PCA.variable <- plot_ly(data = PCA.variable, x = ~PC1, y = ~PC2, type = "scatter", text = ~variable.label)
# plot.PCA.variable
# 
# # set up dataframe for mock biplot plotting
# blankDF <- as.data.frame(matrix(data = 0, nrow = dim(PCA.variable)[1], ncol = dim(PCA.variable)[2]))# create data frame of origin rows
# colnames(blankDF) <- colnames(PCA.variable) # rename columns of blankDF to help with binding
# PCA.variable.biplot <- rbind(PCA.variable, blankDF) # bind origin row data frame to PCA.variable data frame
# PCA.variable.biplot <- PCA.variable.biplot[kronecker(1:(nrow(PCA.variable)), c(0, (nrow(PCA.variable))), "+"), ] # rearrane rows so every other row is the origin
# 
# # plot PCA biplot (lines from origin)
# plot.PCA.variable.biplot <- plot_ly(data = PCA.variable.biplot, x = ~PC1, y = ~PC2, 
#                                    type = "scatter", mode = "lines", line = list(color = "black", width = 2)) %>%
#                                    add_text(text = ~variable.label) %>%
#                                    layout(showlegend = FALSE)
# plot.PCA.variable.biplot
```

```{r factoextra, echo=FALSE, message=FALSE, warning=FALSE}

# # Eigenvalues
# eig.val.factoextra <- get_eigenvalue(res.pca)
# eig.val.factoextra
#   
# # Results for Variables
# res.var <- get_pca_var(res.pca)
# res.var$coord          # Coordinates
# res.var$contrib        # Contributions to the PCs
# res.var$cos2           # Quality of representation 
# # Results for individuals
# res.ind <- get_pca_ind(res.pca)
# res.ind$coord          # Coordinates
# res.ind$contrib        # Contributions to the PCs
# res.ind$cos2           # Quality of representation 
# 
# 
# # fviz_eig(res.pca) # scree plot (using factoextra package?)
# fviz_pca_var(res.pca,
#              col.var = "contrib", # Color by contributions to the PC
#              gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
#              repel = TRUE     # Avoid text overlapping
#              )
# # 


# D.PCA.subset <- DF.PCA[10:dim(DF.PCA),]
# D.PCA.subset <- as.numeric(D.PCA.subset)
# PCAresults <- prcomp(D.PCA.subset)
# PCAresults2 <- princomp(D.PCA.subset)
# 
# 
# plot.PCA <- ggplotly(autoplot(prcomp(t(D.PCA.subset)),
#                        loadings = TRUE, loadings.label = TRUE, loadings.label.size = 4))
# plot.PCA



# PCA <- data.frame(variable = PCA.results$ , # make a data frame organizing the results needed to make a PCA plot
#                   PCAx = PCA.results$x , # get the x coordinates for PCA
#                   PCAy = PCA.results$ , # get the y coordinates for PCA
#                   contib = PCA.results$ , # get the contribution to the PCs
#                   corr = PCA.results$ ,     # get the correlations between variables and dimensions
#                   qual = PCA.results$ ) # quality of the representation, cos^2
```


Row
----------------------------------------------------------

### PCA cluster dendrogram (23 variables)
```{r PCA_dendrogram}
# PCA.5 <- princomp(t(DF.PCA[10:dim(DF.PCA),]),cor = TRUE) # do principal component analysis on data frame with 23 variables
# # plot(PCA.5,type="l") # plot showing variance of each PCA
# # dendro.PCA.5 <- hclust(dist(PCA.5$scores),method = "ward.D2")
# # plot.dendro.PCA.5 <- plot(dendro.PCA.5)
# # plotly.dendro.PCA.5 <- plot_dendro(dendro.PCA.5)
# # plotly.dendro.PCA.5
# # 
# # # 
# # test1 <- ggdendrogram(dendro.PCA.5, rotate = FALSE, size = 2)
# # test1
# # hc <- hclust(dist(PCA.5$scores), method = "ward.D2")
# # dend1 <- as.dendrogram(hc)
# # plot_dendro(dend1, height = 600) %>%
# #   hide_legend() %>%
# #   highlight(persistent = TRUE, dynamic = TRUE)
# 
# 
# # https://plot.ly/ggplot2/ggdendro-dendrograms/
# 
# #dendogram data
# dd.row <- as.dendrogram(hclust(dist(DF.MDS.23)))
# dx <- dendro_data(dd.row)
# 
# # helper function for creating dendograms
# ggdend <- function(df) {
#   ggplot() +
#     geom_segment(data = df, aes(x=x, y=y, xend=xend, yend=yend)) +
#     labs(x = "", y = "") + theme_minimal() +
#     theme(axis.text = element_blank(), axis.ticks = element_blank(),
#           panel.grid = element_blank())
# }
# 
# # x/y dendograms
# px <- ggdend(dx$segments)
# 
# px
# 
# # 
# # # hide axis ticks and grid lines
# # eaxis <- list(
# #   showticklabels = FALSE,
# #   showgrid = FALSE,
# #   zeroline = FALSE
# # )
# # 
# # p_empty <- plot_ly() %>%
# #   # note that margin applies to entire plot, so we can
# #   # add it here to make tick labels more readable
# #   layout(margin = list(l = 200),
# #          xaxis = eaxis,
# #          yaxis = eaxis)
# # 
# # subplot(px, p_empty, p_empty, p_empty, nrows = 2, margin = 0.01)

```












Ternary plots  
================================================================================
`r sample.notes`  
This section is in progress.

